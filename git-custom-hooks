#!/bin/bash
#-------------------------------------------------------------
# Greeting, motd etc. ...
#-------------------------------------------------------------

# Color definitions (taken from Color Bash Prompt HowTo).
# Some colors might look different of some terminals.
# For example, I see 'Bold Red' as 'orange' on my screen,
# hence the 'Green' 'BRed' 'Red' sequence I often use in my prompt.



#cd_reminder will print the name of root folder from any git repo when you will change directory on it 
#to disable this function just comment the next line (put the # at the start of the line)


# Normal Colors
Black='\e[0;30m'        # Black
Red='\e[0;31m'          # Red
Green='\e[0;32m'        # Green
Yellow='\e[0;33m'       # Yellow
Blue='\e[0;34m'         # Blue
Purple='\e[0;35m'       # Purple
Cyan='\e[0;36m'         # Cyan
White='\e[0;37m'        # White

# Bold
BBlack='\e[1;30m'       # Black
BRed='\e[1;31m'         # Red
BGreen='\e[1;32m'       # Green
BYellow='\e[1;33m'      # Yellow
BBlue='\e[1;34m'        # Blue
BPurple='\e[1;35m'      # Purple
BCyan='\e[1;36m'        # Cyan
BWhite='\e[1;37m'       # White

# Background
On_Black='\e[40m'       # Black
On_Red='\e[41m'         # Red
On_Green='\e[42m'       # Green
On_Yellow='\e[43m'      # Yellow
On_Blue='\e[44m'        # Blue
On_Purple='\e[45m'      # Purple
On_Cyan='\e[46m'        # Cyan
On_White='\e[47m'       # White

NC="\e[0m"               # Color Reset

SCRIPT_DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

# Disable openinig the editor on git merge
GIT_MERGE_AUTOEDIT=no
export GIT_MERGE_AUTOEDIT

source $SCRIPT_DIR/figlet

get_repo_data(){
	repo_info="$(\git rev-parse --git-dir HEAD 2>/dev/null)"
	rev_parse_exit_code="$?"
	git_dir_path="${repo_info%$'\n'*}"
}

get_repo_data

reminder_cd() {
	builtin cd "$@" && {
		#show the project name with figlet only if the project is not the current script folder because we use cd command on line 49 to get the current script path
		get_repo_data
		#if git_dir_path is .git that mean we are on root folder of project
		if [[ $git_dir_path == ".git" ]] && [[ $@ != "$( dirname "${BASH_SOURCE[0]}")" ]]
		then
			figlet -c=BRed ${PWD##*/}
		fi
	}
}

custom_git() {
	
	#if is a default git hook, like pre-commit set to true, to can be ignored by this script
	case $1 in
		commit | push | rebase)
		  is_default_hook=true;
		  ;;
		*)
		  is_default_hook=false;
		  ;;
	esac

	#run pre hooks
	run_pre_hook "$@"

	#if exist code from hook is 0 then we can continue to execute git command
	hook_exit_code="$?"
	if [ $hook_exit_code -eq '0' ]; then
		\git "$@"
	fi

	#if is a default git hook, like post-update set to true, to can be ignored by this script
	case $1 in
		update)
		is_default_hook=true;
		  ;;
		*)
		is_default_hook=false;
		  ;;
	esac

	#run post hooks
	run_post_hook "$@"
}

run_pre_hook() {

	#set pre hooks paths
	def_pre_hook="${git_dir_path}/hooks/pre-$1"
	custom_pre_hook="${SCRIPT_DIR}/hooks/pre-$1"
	
	#if pre hook is set on project then execute it and ignore the default one
    if [ -f $def_pre_hook ]; then
		#if the hook is one of the git default hooks, ignore it because is executed by git 
		if [ ! $is_default_hook ]; then
			#execute pre hook if is custom one
			$def_pre_hook "$@"
		fi
	#if pre hook is not set on the project, check if is set on default hooks folder from this script
	elif [ -f $custom_pre_hook ]; then 
		#execute the general custom pre hook
		$custom_pre_hook "$@"
	fi
}

run_post_hook() {

	#set post hooks paths
	def_post_hook="${git_dir_path}/hooks/post-$1"
	custom_post_hook="${SCRIPT_DIR}/hooks/post-$1"

	#if post hook is set on project then execute it and ignore the default one
    if [ -f $def_post_hook ]; then
		#if the hook is one of the git default hooks, ignore it because is executed by git
        if [ ! $is_default_hook ]; then
			#execute post hook if is custom one
            $def_post_hook "$@"
        fi
	#if post hook is not set on the project, check if is set on default hooks folder from this script
    elif [ -f $custom_post_hook ]; then 
		#execute the general custom post hook
        $custom_post_hook "$@"
    fi
}




git_commit ()
{
	
	#get the current branch
	branch=$(git branch | sed -n -e 's/\* //p')
	branch=$(echo "$branch" | sed -r 's/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g')
	
	message="$*"
	
	if [[ $branch == [0-9]* ]]
	then
		message="#${branch} ${message}";
	fi
	
	custom_git commit --no-edit -am "$message"
}

publish()
{
	br_to_pub=$1
	cur_branch=$(git branch | sed -n -e 's/\* //p')
	cur_branch=$(echo "$cur_branch" | sed -r 's/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g')
	message="#${cur_branch} ${*:2}"
	
	printf "\n$BCyan--- Commit changes ---$NC\n"
	
	git commit  --no-edit -am "$message"
	hook_exit_code="$?"
	if [ $hook_exit_code -gt "1" ]; then
		printf " ${BRed} Aborted!\n ${NC}"; return;
	fi
	
	
	printf "\n$BCyan--- Checkout branch $br_to_pub ---$NC\n"
	git checkout "$br_to_pub"
	
    printf "\n$BCyan--- Fetch changes from remote ---$NC\n"
    git fetch

    printf "\n$BCyan--- Reset to origin ---$NC\n"
    git reset --hard origin/$br_to_pub
	
	hook_exit_code="$?"
	if [ $hook_exit_code -gt "0" ]; then
		printf " ${BRed} Aborted!\n ${NC}"; return;
	fi
	
	printf "\n$BCyan--- Merge $cur_branch into $br_to_pub ---$NC\n"
	git merge "$cur_branch"
	
	hook_exit_code="$?"
	if [ $hook_exit_code -gt "0" ]; then
		printf " ${BRed} Aborted!\n ${NC}"; return;
	fi
	
	printf "\n$BCyan--- Push changes into $br_to_pub ---$NC\n"
	git push
	
	hook_exit_code="$?"
	if [ $hook_exit_code -gt "0" ]; then
		printf " ${BRed} Aborted!\n ${NC}"; return;
	fi
	
	printf "\n$BCyan--- Checkout branch $cur_branch ---$NC\n"
	git checkout "$cur_branch"
}   

alias git=custom_git
alias cd=reminder_cd
alias pb=publish
alias gc=git_commit
